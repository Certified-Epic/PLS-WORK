<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warframe-Style Star Chart</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Roboto Mono', monospace;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            font-family: 'Roboto Mono', monospace;
        }
        .planet-label, .junction-label {
            position: absolute;
            color: #fff;
            white-space: nowrap;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            font-size: 1rem;
        }
        .achievement-detail-container {
            position: absolute;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #fff;
            box-shadow: 0 0 10px #fff, inset 0 0 5px #fff;
            color: #fff;
            padding: 1rem;
            border-radius: 0.5rem;
            max-width: 300px;
            text-align: left;
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
        }
        .achievement-detail-container.active {
            opacity: 1;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: #1a1a1a;
            color: #fff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 0 10px #fff, inset 0 0 5px #fff;
            width: 90%;
            max-width: 500px;
        }
        .modal-content-admin {
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .animated-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: #000;
        }
        .admin-button {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            pointer-events: auto;
        }
        .path-pulse-fragment {
            display: none; /* Hide template initially */
        }
    </style>
</head>
<body>
    <div class="animated-background"></div>
    <div id="ui-overlay" class="ui-overlay">
        <!-- Planet and Junction labels will be added here dynamically -->
        <div id="achievement-detail" class="achievement-detail-container pointer-events-auto hidden">
            <h3 class="text-lg font-bold" id="detail-title"></h3>
            <p class="text-sm mt-2" id="detail-description"></p>
            <div id="detail-completion-status" class="mt-4"></div>
            <button id="complete-button" class="mt-4 px-4 py-2 bg-green-500 rounded-lg shadow-sm hover:bg-green-600 transition-colors hidden">Mark as Complete</button>
        </div>
        <button id="admin-button" class="admin-button px-4 py-2 bg-gray-800 text-white rounded-lg shadow-lg hover:bg-gray-700 transition-colors">Admin Panel</button>
        <div id="volume-controls" class="absolute bottom-1 right-1/2 translate-x-1/2 p-2 bg-gray-800 text-white rounded-lg shadow-lg flex items-center gap-2">
            <label for="bgm-volume" class="text-xs">BGM:</label>
            <input type="range" id="bgm-volume" min="0" max="1" step="0.01" value="0.5">
            <label for="sfx-volume" class="text-xs">SFX:</label>
            <input type="range" id="sfx-volume" min="0" max="1" step="0.01" value="0.75">
        </div>
    </div>
    
    <!-- Modals -->
    <div id="modal-container-login" class="modal">
        <div class="modal-content text-center">
            <h2 class="text-xl font-bold mb-4">Admin Login</h2>
            <input type="password" id="admin-password" class="w-full p-2 bg-gray-900 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-white" placeholder="Enter password...">
            <button id="login-button" class="mt-4 px-6 py-2 bg-blue-500 rounded-lg hover:bg-blue-600 transition-colors w-full">Login</button>
            <button id="close-login" class="mt-2 text-sm text-gray-400 hover:text-gray-200">Cancel</button>
        </div>
    </div>

    <div id="modal-container-admin" class="modal">
        <div class="modal-content modal-content-admin text-center">
            <h2 class="text-xl font-bold mb-4">Admin Panel</h2>
            <div id="admin-controls" class="space-y-4">
                <button id="unlock-all-tiers" class="px-4 py-2 bg-green-500 rounded-lg hover:bg-green-600 transition-colors w-full">Unlock All Tiers (Visual Only)</button>
                <button id="reset-all" class="px-4 py-2 bg-red-500 rounded-lg hover:bg-red-600 transition-colors w-full">Reset All Achievements</button>
                <button id="export-json" class="px-4 py-2 bg-purple-500 rounded-lg hover:bg-purple-600 transition-colors w-full">Export Current Data</button>
                <div id="admin-editor" class="text-left mt-4">
                    <h3 class="text-lg font-bold mb-2">Edit Achievements</h3>
                    <select id="admin-planet-select" class="w-full p-2 bg-gray-900 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-white"></select>
                    <div id="achievements-list" class="mt-4 space-y-2 max-h-64 overflow-y-auto"></div>
                </div>
            </div>
            <button id="close-admin" class="mt-4 text-sm text-gray-400 hover:text-gray-200">Close</button>
        </div>
    </div>

    <!-- Hidden audio elements -->
    <audio id="bgm-audio" loop></audio>
    <audio id="sfx-audio" preload="auto"></audio>

    <script>
        // Global variables and constants
        let scene, camera, renderer, audioListener, backgroundMusic;
        let corePlanets = [];
        let tierPlanets = [];
        let lines = [];
        let labels = [];
        let achievementNodes = [];
        let junctions = [];
        let activeAchievementDetails = null;
        let isPanning = false;
        let previousMousePosition = { x: 0, y: 0 };
        const orbitRadius = 10;
        const tierOrbitRadius = 2.5;
        const planetScale = 1;
        const tierPlanetScale = 0.5;
        const adminPassword = "warframe_admin_2025";
        let achievementsData = {};
        let config = {};

        // Asset URLs
        const assetUrls = {
            center: 'https://files.catbox.moe/8eyie5.png',
            planet: 'https://files.catbox.moe/b0zug5.png',
            lock: 'https://files.catbox.moe/jbhsjx.png',
            pulse: 'https://files.catbox.moe/2tciqz.png',
            node: 'https://files.catbox.moe/i76wxr.png',
            junction: 'https://files.catbox.moe/z7t4yb.png',
            hoverSound: 'https://files.catbox.moe/kftxci.mp3',
            zoomSound: 'https://files.catbox.moe/qza6ii.mp3',
            backgroundMusic: 'https://files.catbox.moe/ej4uff.mp3',
        };

        // Utility functions
        async function loadJSON(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Could not load JSON from ${url}:`, error);
                return null;
            }
        }

        function createStarfield() {
            const starGeo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color();
            for (let i = 0; i < 5000; i++) {
                const x = THREE.MathUtils.randFloatSpread(400);
                const y = THREE.MathUtils.randFloatSpread(400);
                const z = THREE.MathUtils.randFloatSpread(400);
                positions.push(x, y, z);
                color.setHSL(Math.random() * 0.2, 0.5, 0.8 + Math.random() * 0.2); // White-ish stars
                colors.push(color.r, color.g, color.b);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const starMat = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
            });
            const starField = new THREE.Points(starGeo, starMat);
            scene.add(starField);
        }

        function createPulsingEffect(object) {
            object.material.opacity = 0.5 + Math.sin(Date.now() * 0.005) * 0.25;
            object.material.needsUpdate = true;
        }

        // Main scene setup
        function init() {
            // Scene, Camera, Renderer
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 20;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Audio setup
            audioListener = new THREE.AudioListener();
            camera.add(audioListener);
            backgroundMusic = new THREE.Audio(audioListener);
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load(assetUrls.backgroundMusic, function(buffer) {
                backgroundMusic.setBuffer(buffer);
                backgroundMusic.setLoop(true);
                backgroundMusic.setVolume(config.audio.bgmVolume);
                // Autoplay will be handled on first user interaction
            });

            // Lights
            scene.add(new THREE.AmbientLight(0x404040, 5));

            // Load textures and create objects
            const textureLoader = new THREE.TextureLoader();
            const corePlanetTexture = textureLoader.load(assetUrls.planet);
            const centralImageTexture = textureLoader.load(assetUrls.center);
            const achievementNodeTexture = textureLoader.load(assetUrls.node);
            const junctionTexture = textureLoader.load(assetUrls.junction);
            const lockTexture = textureLoader.load(assetUrls.lock);
            const pulseTexture = textureLoader.load(assetUrls.pulse);

            // Central Geometric Image
            const centralGeo = new THREE.PlaneGeometry(3, 3);
            const centralMat = new THREE.MeshBasicMaterial({ map: centralImageTexture, transparent: true, blending: THREE.AdditiveBlending, opacity: 0.8 });
            const centralMesh = new THREE.Mesh(centralGeo, centralMat);
            scene.add(centralMesh);

            // Starfield
            createStarfield();

            // Create Planets and connections
            function createPlanetsAndLinks() {
                corePlanets.forEach(p => scene.remove(p));
                tierPlanets.forEach(p => scene.remove(p));
                lines.forEach(l => scene.remove(l));
                corePlanets = [];
                tierPlanets = [];
                lines = [];
                labels.forEach(l => l.remove());
                labels = [];
                achievementNodes.forEach(n => scene.remove(n));
                achievementNodes = [];
                junctions.forEach(j => scene.remove(j));
                junctions = [];

                achievementsData.planets.forEach((corePlanet, coreIndex) => {
                    // Core Planet
                    const corePlanetAngle = (coreIndex / achievementsData.planets.length) * Math.PI * 2;
                    const corePlanetX = Math.cos(corePlanetAngle) * orbitRadius;
                    const corePlanetY = Math.sin(corePlanetAngle) * orbitRadius;
                    const corePlanetMesh = new THREE.Mesh(
                        new THREE.PlaneGeometry(planetScale, planetScale),
                        new THREE.MeshBasicMaterial({ map: corePlanetTexture, transparent: true, blending: THREE.AdditiveBlending })
                    );
                    corePlanetMesh.position.set(corePlanetX, corePlanetY, 0);
                    corePlanetMesh.userData = { isPlanet: true, type: 'core', data: corePlanet };
                    corePlanets.push(corePlanetMesh);
                    scene.add(corePlanetMesh);

                    // Core Planet Label
                    const label = document.createElement('div');
                    label.className = 'planet-label';
                    label.textContent = corePlanet.planetName.toUpperCase();
                    document.getElementById('ui-overlay').appendChild(label);
                    labels.push(label);

                    // Tier Planets
                    corePlanet.tiers.forEach((tier, tierIndex) => {
                        const tierPlanetAngle = (tierIndex / corePlanet.tiers.length) * Math.PI * 2;
                        const tierPlanetX = corePlanetX + Math.cos(tierPlanetAngle) * tierOrbitRadius;
                        const tierPlanetY = corePlanetY + Math.sin(tierPlanetAngle) * tierOrbitRadius;
                        const tierPlanetMesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(tierPlanetScale, tierPlanetScale),
                            new THREE.MeshBasicMaterial({ map: corePlanetTexture, transparent: true, blending: THREE.AdditiveBlending })
                        );
                        tierPlanetMesh.position.set(tierPlanetX, tierPlanetY, 0);
                        tierPlanetMesh.userData = { isPlanet: true, type: 'tier', data: tier };
                        tierPlanets.push(tierPlanetMesh);
                        scene.add(tierPlanetMesh);

                        // Line connecting tier to core
                        const points = [
                            new THREE.Vector3(corePlanetX, corePlanetY, 0),
                            new THREE.Vector3(tierPlanetX, tierPlanetY, 0)
                        ];
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(
                            geometry,
                            new THREE.LineBasicMaterial({
                                color: 0xffffff,
                                transparent: true,
                                opacity: 0.5,
                                blending: THREE.AdditiveBlending
                            })
                        );
                        lines.push(line);
                        scene.add(line);
                    });
                });
            }

            // Event listeners
            let raycaster = new THREE.Raycaster();
            let mouse = new THREE.Vector2();

            function onMouseMove(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }

            function onMouseDown(event) {
                isPanning = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
                document.body.style.cursor = 'grabbing';
            }

            function onMouseUp() {
                isPanning = false;
                document.body.style.cursor = 'grab';
            }

            function onMouseClick(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([...corePlanets, ...tierPlanets, ...achievementNodes, ...junctions]);

                if (intersects.length > 0) {
                    const intersectedObject = intersects[0].object;
                    if (intersectedObject.userData.isPlanet) {
                        const targetPosition = intersectedObject.position.clone();
                        // Zoom and center on the planet
                        // For a real app, this would be a smooth transition
                        camera.position.set(targetPosition.x, targetPosition.y, 10);
                        playSound(assetUrls.zoomSound, config.audio.sfxVolume);
                        
                        // Handle Planet Click logic here
                        const planetData = intersectedObject.userData.data;
                        console.log(`Clicked on planet: ${planetData.planetName || planetData.tierName}`);

                        // For now, let's just log the click. A full implementation would
                        // show the achievement nodes on the planet surface.
                    }
                } else {
                    // No object clicked, close any open details
                    hideAchievementDetails();
                }
            }

            function onWheel(event) {
                const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.z *= zoomFactor;
            }

            // Custom pan and zoom for touch
            let touchStartTime = 0;
            const doubleTapDelay = 300;
            let lastTap = 0;
            let lastTouch = { x: 0, y: 0 };
            
            function onTouchStart(event) {
                if (event.touches.length === 1) {
                    const now = Date.now();
                    if (now - lastTap < doubleTapDelay) {
                        // This is a double tap
                        onMouseClick({ clientX: event.touches[0].clientX, clientY: event.touches[0].clientY });
                        lastTap = 0;
                    } else {
                        lastTap = now;
                    }
                    lastTouch.x = event.touches[0].clientX;
                    lastTouch.y = event.touches[0].clientY;
                } else if (event.touches.length === 2) {
                    // Pinch to zoom
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    lastTouch.distance = Math.sqrt(dx * dx + dy * dy);
                }
            }
            
            function onTouchMove(event) {
                event.preventDefault();
                if (event.touches.length === 1) {
                    // Pan
                    const dx = event.touches[0].clientX - lastTouch.x;
                    const dy = event.touches[0].clientY - lastTouch.y;
                    camera.position.x -= dx * 0.01;
                    camera.position.y += dy * 0.01;
                    lastTouch.x = event.touches[0].clientX;
                    lastTouch.y = event.touches[0].clientY;
                } else if (event.touches.length === 2) {
                    // Zoom
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);
                    const zoomFactor = lastTouch.distance / currentDistance;
                    camera.position.z *= zoomFactor;
                    lastTouch.distance = currentDistance;
                }
            }
            
            function onTouchEnd() {
                // Do nothing for now
            }

            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('click', onMouseClick, false);
            renderer.domElement.addEventListener('wheel', onWheel, false);
            
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);

            window.addEventListener('resize', onWindowResize, false);

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            // Audio controls
            document.getElementById('bgm-volume').addEventListener('input', function(e) {
                if (backgroundMusic) {
                    backgroundMusic.setVolume(parseFloat(e.target.value));
                    config.audio.bgmVolume = parseFloat(e.target.value);
                }
            });
            document.getElementById('sfx-volume').addEventListener('input', function(e) {
                config.audio.sfxVolume = parseFloat(e.target.value);
            });
            
            function playSound(url, volume) {
                const sound = new THREE.Audio(audioListener);
                const loader = new THREE.AudioLoader();
                loader.load(url, function(buffer) {
                    sound.setBuffer(buffer);
                    sound.setVolume(volume);
                    sound.play();
                });
            }

            // Admin Panel UI logic
            document.getElementById('admin-button').addEventListener('click', () => {
                showModal('modal-container-login');
            });

            document.getElementById('close-login').addEventListener('click', () => {
                hideModal('modal-container-login');
            });
            
            document.getElementById('close-admin').addEventListener('click', () => {
                hideModal('modal-container-admin');
            });

            document.getElementById('login-button').addEventListener('click', () => {
                const password = document.getElementById('admin-password').value;
                if (password === adminPassword) {
                    hideModal('modal-container-login');
                    showModal('modal-container-admin');
                    document.getElementById('admin-password').value = '';
                } else {
                    alert('Incorrect password!'); // Using alert for a simple message, but a custom modal would be better.
                }
            });

            document.getElementById('reset-all').addEventListener('click', () => {
                const confirmation = window.confirm("Are you sure you want to reset all achievements?");
                if (confirmation) {
                    resetAchievements();
                }
            });

            document.getElementById('export-json').addEventListener('click', () => {
                exportData();
            });

            function showModal(id) {
                document.getElementById(id).classList.add('active');
            }

            function hideModal(id) {
                document.getElementById(id).classList.remove('active');
            }

            function resetAchievements() {
                achievementsData.planets.forEach(p => {
                    p.tiers.forEach(t => {
                        t.achievements.forEach(a => {
                            a.status = a.tier === 1 ? 'available' : 'locked';
                            a.dateCompleted = null;
                        });
                    });
                });
                saveAchievements();
                createPlanetsAndLinks();
                // A better approach would be to redraw nodes without recreating everything.
            }

            function exportData() {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(achievementsData, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "achievements.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            }

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);

                // Update UI elements position
                labels.forEach(label => {
                    const object = label.userData.object;
                    const vector = new THREE.Vector3();
                    object.getWorldPosition(vector);
                    vector.project(camera);

                    const x = (vector.x * .5 + .5) * window.innerWidth;
                    const y = (-vector.y * .5 + .5) * window.innerHeight;

                    label.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
                    label.style.opacity = camera.position.z < 15 ? 1 : 0;
                });
            }

            // Initial load
            async function initializeData() {
                achievementsData = await loadJSON('achievements.json');
                config = await loadJSON('config.json');
                if (achievementsData && config) {
                    createPlanetsAndLinks();
                    animate();
                    
                    // Set up initial audio levels
                    document.getElementById('bgm-volume').value = config.audio.bgmVolume;
                    document.getElementById('sfx-volume').value = config.audio.sfxVolume;

                    // First click to enable audio
                    document.addEventListener('click', () => {
                        if (!backgroundMusic.isPlaying) {
                            backgroundMusic.play();
                        }
                    }, { once: true });
                }
            }

            // Function to show achievement details
            function showAchievementDetails(achievement) {
                // This would be implemented in a more complex app
            }
            
            // Function to hide achievement details
            function hideAchievementDetails() {
                // This would be implemented in a more complex app
            }

            // Function to save data to local storage (for persistence)
            function saveAchievements() {
                localStorage.setItem('achievementsData', JSON.stringify(achievementsData));
            }

            // Main entry point
            initializeData();
        }

        window.onload = init;
    </script>
</body>
</html>
